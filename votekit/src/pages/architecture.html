<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Architecture | VoteKit Demo</title>
<meta name="generator" content="Jekyll v4.1.1" />
<meta property="og:title" content="Architecture" />
<meta name="author" content="Paretoman" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Here’s a demo site that uses votekit. Votekit is an explorable sandbox that shows how different voting methods work. Single elections are presented visually using a spatial opinion model. Ensembles of elections are also presented with distributions of winning positions. (The rest of this description will become more accurate with time.) Some consideration of strategy is performed. Voting methods include single-winner systems like plurality, approval, condorcet methods, instant runoff, score, star, etc. Electoral methods also include proportional multi-member district methods like the Single Transferable Vote, Monroe, Thiele’s Proportional Approval Voting, Phragmen’s method, etc. Electoral methods also include party-list proportional methods like d’Hondt, Huntington-Hill, Webster, etc. Additional electoral methods include MMP and OLPR." />
<meta property="og:description" content="Here’s a demo site that uses votekit. Votekit is an explorable sandbox that shows how different voting methods work. Single elections are presented visually using a spatial opinion model. Ensembles of elections are also presented with distributions of winning positions. (The rest of this description will become more accurate with time.) Some consideration of strategy is performed. Voting methods include single-winner systems like plurality, approval, condorcet methods, instant runoff, score, star, etc. Electoral methods also include proportional multi-member district methods like the Single Transferable Vote, Monroe, Thiele’s Proportional Approval Voting, Phragmen’s method, etc. Electoral methods also include party-list proportional methods like d’Hondt, Huntington-Hill, Webster, etc. Additional electoral methods include MMP and OLPR." />
<link rel="canonical" href="https://paretoman.github.io/votekit-example/votekit/src/pages/architecture.html" />
<meta property="og:url" content="https://paretoman.github.io/votekit-example/votekit/src/pages/architecture.html" />
<meta property="og:site_name" content="VoteKit Demo" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Architecture" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebPage","author":{"@type":"Person","name":"Paretoman"},"description":"Here’s a demo site that uses votekit. Votekit is an explorable sandbox that shows how different voting methods work. Single elections are presented visually using a spatial opinion model. Ensembles of elections are also presented with distributions of winning positions. (The rest of this description will become more accurate with time.) Some consideration of strategy is performed. Voting methods include single-winner systems like plurality, approval, condorcet methods, instant runoff, score, star, etc. Electoral methods also include proportional multi-member district methods like the Single Transferable Vote, Monroe, Thiele’s Proportional Approval Voting, Phragmen’s method, etc. Electoral methods also include party-list proportional methods like d’Hondt, Huntington-Hill, Webster, etc. Additional electoral methods include MMP and OLPR.","headline":"Architecture","url":"https://paretoman.github.io/votekit-example/votekit/src/pages/architecture.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/votekit-example/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://paretoman.github.io/votekit-example/feed.xml" title="VoteKit Demo" /><script>
if(!(window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1")) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-172540609-1', 'auto');
  ga('send', 'pageview');
}
</script>
  
</head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/votekit-example/">VoteKit Demo</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/votekit-example/about/">About</a><a class="page-link" href="/votekit-example/votekit/src/pages/architecture.html">Architecture</a><a class="page-link" href="/votekit-example/votekit/src/pages/blog.html">Blog</a><a class="page-link" href="/votekit-example/votekit/src/pages/code_1d.html">1D</a><a class="page-link" href="/votekit-example/votekit/src/pages/code_commands.html">Commands</a><a class="page-link" href="/votekit-example/votekit/src/pages/code_screen.html">Screen</a><a class="page-link" href="/votekit-example/votekit/src/pages/code_sim.html">Sim</a><a class="page-link" href="/votekit-example/devlog/">Development Log</a><a class="page-link" href="/votekit-example/votekit/src/pages/">Pages</a><a class="page-link" href="/votekit-example/submodule-instructions/">Submodule Instructions</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <p>The architecture tries to be context-oriented. I mean that we keep an idea of the task to be performed. There are three main parts: math, sim, and ui.</p>

<h2 id="math">Math</h2>

<p>Do the math of the election, casting and counting votes.</p>

<ul>
  <li>Election
    <ul>
      <li>The Election class just has code in the context of running an election. Voters and candidates are passed as arguments to functions in the Election class.</li>
      <li>There are sim-type-specific classes that include Election as a component: ElectionOne, ElectionSample, and ElectionGeo.</li>
    </ul>
  </li>
  <li>CastVotes
    <ul>
      <li>Voters cast their ballots.</li>
      <li>A distribution of a population of voters is sampled. A 2D spatial model is used to make the decision of how to vote or who to vote for.</li>
      <li>The vote is aggregated into a set.</li>
    </ul>
  </li>
  <li>CountVotes
    <ul>
      <li>The difference between CountVotes and Election is that Election is a mediator for all the aspects of an election such as casting a vote, or the number of dimensions, while CountVotes is a component of the Election that just considers the votes and the result of counting. Then CountVotes returns a summary of the results of the count.</li>
    </ul>
  </li>
</ul>

<h2 id="sim">Sim</h2>

<p>Create a 2D spatial model.</p>

<ul>
  <li>Sim
    <ul>
      <li>The Sim class manages voter entities and candidate entities.</li>
      <li>Entities are visual objects that can be controlled by the user. These include voters and candidates.</li>
      <li>Sim is a state machine with the following states: SimGeoOne, SimOne1D, SimOne2D, and SimSample. Each state is like a different game. Entities are shared between states. Wrappers use the entities as components to provide additional functionality to the states.</li>
      <li>State Updates
  The basic process is: Run an election. Get result. Visualize result. The election code handles any changes. The electionResults communicates how to visualize the election.</li>
    </ul>
  </li>
  <li>Voters
    <ul>
      <li>VoterShape represents a continuous population of voters.
        <ul>
          <li>The other classes below are responsible for managing interactions between voterShapes, as opposed to managing an individual voterShape.</li>
        </ul>
      </li>
      <li>VoterShapeAdd manages a list of these VoterShape objects and adds new ones.
        <ul>
          <li>Registrar is the component that manages the list.</li>
          <li>VoterCommander is the component that handles commands for each VoterShape.</li>
        </ul>
      </li>
      <li>VoterSim deals with dragging the VoterShape for a particular sim.
        <ul>
          <li>voterShape is a component of VoterSim.</li>
        </ul>
      </li>
      <li>VoterSimList manages a list of VoterSim objects for each sim. It provides a count of the VoterShapes and renders the VoterShapes. It is important because the “exists” property of a VoterShape can be toggled, so we have to filter the list of voters
        <ul>
          <li>VoterGeoList is a variation on VoterSimList with more functionality for districts.</li>
        </ul>
      </li>
      <li>Viz* draws the voters because there is more context to draw them as a group than individually.
        <ul>
          <li>VizOneVoronoi - for votes cast like plurality.</li>
          <li>VizOneGrid - for votes cast like score.</li>
          <li>VizGeo - for votes cast in districts.</li>
          <li>All implement an abstract class of Viz, where there is an update and a render function.</li>
        </ul>
      </li>
      <li>Viz* calls specialized drawing functions for each viz type:
        <ul>
          <li>GeoMaps draws the voters in tracts and districts.</li>
          <li>Voronoi1D/2D draws voronoi diagrams.</li>
          <li>Grid1D/2D draws grids of votes.</li>
          <li>VoterRender1D/2D has methods to draw the voters outside of any other context.</li>
        </ul>
      </li>
      <li>VoterTest is a copy of VoterShape, mostly. VoterTest exists outside of these other classes. It doesn’t have command history and doesn’t interact with other voters. It’s just a test.</li>
      <li>CircleGraphic makes an animated circle.</li>
      <li>Data types:
        <ul>
          <li>These are the standard ways of referring to voter objects that are not classes.</li>
          <li>voterGroup: an object with a shape1, shape2, and weight (optional) property.</li>
          <li>voterGeom:
            <ul>
              <li>For 2D, an array of objects: {x,y,w}.</li>
              <li>For 1D, an array of objects: {x,w,densityProfile}.</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Candidates
    <ul>
      <li>Candidate represents a single candidate. It keeps its state, works with undo, and has render functions.</li>
      <li>CandidateAdd manages a list of candidates and adds new ones.
        <ul>
          <li>Registrar is the component that manages the list.</li>
          <li>CandidateCommander is the component that handles commands for each Candidate.</li>
        </ul>
      </li>
      <li>CandidateSim deals with dragging the Candidate for a particular sim.</li>
      <li>CandidateSimList manages a list of CandidateSim objects and tracks whether candidates exist and provides functions to return an array of Candidate objects. It also handles methods that apply to all the members of the list so you don’t have to loop through the Candidate objects on your own.</li>
      <li>SquareGraphic makes an animated square and shows stats.</li>
      <li>Data types:
        <ul>
          <li>I made a standard way of referring to candidates as objects that are not classes.</li>
          <li>canGeoms:
            <ul>
              <li>For 2D, an array of objects: {x,y}.</li>
              <li>For 1D, an array of objects: {x}.</li>
            </ul>
          </li>
          <li>canList: An array of Candidate objects.</li>
          <li>candidateSimList: a CandidateSimList object.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>CandidateDns
    <ul>
      <li>Nearly identical mirrors of the classes for Candidates above exist for CandidateDns.</li>
    </ul>
  </li>
</ul>

<h2 id="ui">UI</h2>

<ul>
  <li>UI
    <ul>
      <li>Sandbox is the main user interface.</li>
      <li>Changes is a class that keeps track of a list of changes. When the Sim’s update method is called, the Sim checks if there are any changes and that controls the flow of the program. Updates are called on every animation frame.</li>
      <li>Screen is a context for drawing.</li>
      <li>Layout puts divs in order.</li>
      <li>doubleSandbox provides two sandboxes that are linked.</li>
    </ul>
  </li>
  <li>Command
    <ul>
      <li>Implement configuration that can be saved to text.</li>
      <li>Implement undo and redo.</li>
    </ul>
  </li>
  <li>index.html
    <ul>
      <li>The main file that shows a sandbox.</li>
    </ul>
  </li>
  <li>lib
    <ul>
      <li>External libraries, copied here using snowpack.</li>
    </ul>
  </li>
  <li>Menu
    <ul>
      <li>Implementing a menu above the main screen.</li>
    </ul>
  </li>
  <li>Pages
    <ul>
      <li>Documentation for the code, and a few test pages.</li>
    </ul>
  </li>
  <li>s
    <ul>
      <li>A standalone sandbox page to link to when saving the configuration to a link.</li>
    </ul>
  </li>
  <li>Tooltips
    <ul>
      <li>Make a tooltip appear when an entity is clicked or a blank space is clicked.</li>
    </ul>
  </li>
  <li>Test
    <ul>
      <li>A bare bones unit test for now. Should do more.</li>
    </ul>
  </li>
  <li>Viz
    <ul>
      <li>Draws visualizations of the voters and candidates.</li>
      <li>This is preferred to having the voters and candidates draw themselves because there can be interactions and overlaps.</li>
    </ul>
  </li>
</ul>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/votekit-example/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">VoteKit Demo</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Paretoman</li><li><a class="u-email" href="mailto:smartvotingsimulator1@gmail.com">smartvotingsimulator1@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/paretoman"><svg class="svg-icon"><use xlink:href="/votekit-example/assets/minima-social-icons.svg#github"></use></svg> <span class="username">paretoman</span></a></li><li><a href="https://www.twitter.com/paretoman1"><svg class="svg-icon"><use xlink:href="/votekit-example/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">paretoman1</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Here&#39;s a demo site that uses votekit. Votekit is an explorable sandbox that shows how different voting methods work. Single elections are presented visually using a spatial opinion model. Ensembles of elections are also presented with distributions of winning positions. (The rest of this description will become more accurate with time.) Some consideration of strategy is performed. Voting methods include single-winner systems like plurality, approval, condorcet methods, instant runoff, score, star, etc. Electoral methods also include proportional multi-member district methods like the Single Transferable Vote, Monroe, Thiele&#39;s Proportional Approval Voting, Phragmen&#39;s method, etc. Electoral methods also include party-list proportional methods like d&#39;Hondt, Huntington-Hill, Webster, etc. Additional electoral methods include MMP and OLPR.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
